# 자체 서버 연동하기

자체 서버의 로깅용 API와 함께 `event-tracker`를 사용하여 이벤트 데이터를 수집하고 분석하는 방법을 알아보겠습니다. 배칭, 인증, 에러 처리 등을 포함한 완전한 솔루션을 제공합니다.

## 서버 API 설계

### 1. 이벤트 수집 엔드포인트

```typescript
// server/types/event.ts
interface EventData {
  eventName: string;
  userId?: string;
  sessionId?: string;
  timestamp: number;
  pageInfo: {
    url: string;
    title: string;
    referrer?: string;
  };
  userAgent: string;
  ip?: string;
  params: Record<string, any>;
  metadata?: {
    source: "client" | "server";
    version: string;
    environment: "development" | "staging" | "production";
  };
}

interface BatchEventData {
  events: EventData[];
  batchId: string;
  timestamp: number;
}
```

### 2. Express.js 서버 예제

```typescript
// server/app.ts
import express from "express";
import cors from "cors";
import rateLimit from "express-rate-limit";
import helmet from "helmet";
import { EventController } from "./controllers/EventController";
import { AuthMiddleware } from "./middleware/AuthMiddleware";
import { ValidationMiddleware } from "./middleware/ValidationMiddleware";

const app = express();

// 보안 미들웨어
app.use(helmet());
app.use(
  cors({
    origin: process.env.ALLOWED_ORIGINS?.split(",") || ["http://localhost:3000"],
    credentials: true,
  }),
);

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15분
  max: 100, // IP당 최대 100개 요청
  message: "Too many requests from this IP",
});
app.use("/api/events", limiter);

// Body parsing
app.use(express.json({ limit: "10mb" }));

// 인증 미들웨어
app.use("/api/events", AuthMiddleware.verifyApiKey);

// 이벤트 수집 엔드포인트
app.post("/api/events/single", ValidationMiddleware.validateEvent, EventController.trackSingleEvent);

app.post("/api/events/batch", ValidationMiddleware.validateBatchEvent, EventController.trackBatchEvents);

// 헬스체크
app.get("/api/health", (req, res) => {
  res.json({ status: "ok", timestamp: Date.now() });
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Event tracking server running on port ${PORT}`);
});
```

### 3. 이벤트 컨트롤러

```typescript
// server/controllers/EventController.ts
import { Request, Response } from "express";
import { EventService } from "../services/EventService";
import { Logger } from "../utils/Logger";

export class EventController {
  static async trackSingleEvent(req: Request, res: Response) {
    try {
      const eventData = req.body;

      // IP 주소 추가
      eventData.ip = req.ip || req.connection.remoteAddress;

      // 이벤트 처리
      await EventService.processEvent(eventData);

      Logger.info("Single event tracked", { eventName: eventData.eventName, userId: eventData.userId });

      res.status(200).json({
        success: true,
        message: "Event tracked successfully",
        eventId: eventData.timestamp,
      });
    } catch (error) {
      Logger.error("Failed to track single event", error);
      res.status(500).json({
        success: false,
        message: "Internal server error",
      });
    }
  }

  static async trackBatchEvents(req: Request, res: Response) {
    try {
      const { events, batchId } = req.body;

      // 배치 이벤트 처리
      const results = await EventService.processBatchEvents(events, batchId);

      Logger.info("Batch events tracked", {
        batchId,
        eventCount: events.length,
        successCount: results.successCount,
        failureCount: results.failureCount,
      });

      res.status(200).json({
        success: true,
        message: "Batch events tracked successfully",
        batchId,
        results,
      });
    } catch (error) {
      Logger.error("Failed to track batch events", error);
      res.status(500).json({
        success: false,
        message: "Internal server error",
      });
    }
  }
}
```

### 4. 이벤트 서비스

```typescript
// server/services/EventService.ts
import { EventData, BatchEventData } from "../types/event";
import { DatabaseService } from "./DatabaseService";
import { AnalyticsService } from "./AnalyticsService";
import { Logger } from "../utils/Logger";

export class EventService {
  static async processEvent(eventData: EventData) {
    try {
      // 데이터베이스에 저장
      await DatabaseService.saveEvent(eventData);

      // 실시간 분석 처리
      await AnalyticsService.processEvent(eventData);

      // 특정 이벤트에 대한 알림
      if (eventData.eventName === "error" || eventData.eventName === "purchase") {
        await this.sendNotification(eventData);
      }
    } catch (error) {
      Logger.error("Failed to process event", { eventData, error });
      throw error;
    }
  }

  static async processBatchEvents(events: EventData[], batchId: string) {
    const results = {
      successCount: 0,
      failureCount: 0,
      errors: [] as any[],
    };

    for (const event of events) {
      try {
        await this.processEvent(event);
        results.successCount++;
      } catch (error) {
        results.failureCount++;
        results.errors.push({
          eventName: event.eventName,
          error: error.message,
        });
      }
    }

    // 배치 처리 결과 로깅
    Logger.info("Batch processing completed", { batchId, results });

    return results;
  }

  private static async sendNotification(eventData: EventData) {
    // Slack, 이메일 등으로 알림 전송
    if (eventData.eventName === "error") {
      await this.sendErrorAlert(eventData);
    } else if (eventData.eventName === "purchase") {
      await this.sendPurchaseNotification(eventData);
    }
  }

  private static async sendErrorAlert(eventData: EventData) {
    // 에러 알림 로직
    console.log("Error alert sent:", eventData);
  }

  private static async sendPurchaseNotification(eventData: EventData) {
    // 구매 알림 로직
    console.log("Purchase notification sent:", eventData);
  }
}
```

## 클라이언트 설정

### 1. 자체 서버 트래커

```tsx
// trackers/selfHostedTracker.ts
import { createTracker } from "@offlegacy/event-tracker";

interface SelfHostedContext {
  userId?: string;
  sessionId?: string;
  apiKey?: string;
  environment: 'development' | 'staging' | 'production';
}

interface SelfHostedEventParams {
  eventName: string;
  category?: string;
  action?: string;
  label?: string;
  value?: number;
  customData?: Record<string, any>;
}

// API 설정
const API_CONFIG = {
  baseUrl: process.env.NEXT_PUBLIC_EVENT_API_URL || 'http://localhost:3001',
  apiKey: process.env.NEXT_PUBLIC_EVENT_API_KEY,
  timeout: 5000,
  retryAttempts: 3,
  retryDelay: 1000,
};

// 이벤트 전송 함수
const sendEvent = async (params: SelfHostedEventParams, context: SelfHostedContext) => {
  const eventData = {
    eventName: params.eventName,
    userId: context.userId,
    sessionId: context.sessionId,
    timestamp: Date.now(),
    pageInfo: {
      url: window.location.href,
      title: document.title,
      referrer: document.referrer,
    },
    userAgent: navigator.userAgent,
    params: {
      category: params.category,
      action: params.action,
      label: params.label,
      value: params.value,
      ...params.customData,
    },
    metadata: {
      source: 'client',
      version: '1.0.0',
      environment: context.environment,
    },
  };

  try {
    const response = await fetch(`${API_CONFIG.baseUrl}/api/events/single`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${context.apiKey || API_CONFIG.apiKey}`,
      },
      body: JSON.stringify(eventData),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result = await response.json();
    console.log('✅ 이벤트 전송 성공:', params.eventName, result);

    return result;
  } catch (error) {
    console.error('❌ 이벤트 전송 실패:', params.eventName, error);
    throw error;
  }
};

// 재시도 로직
const retryWithBackoff = async <T>(
  fn: () => Promise<T>,
  retries: number = API_CONFIG.retryAttempts,
  delay: number = API_CONFIG.retryDelay
): Promise<T> => {
  try {
    return await fn();
  } catch (error) {
    if (retries > 0) {
      await new Promise(resolve => setTimeout(resolve, delay));
      return retryWithBackoff(fn, retries - 1, delay * 2);
    }
    throw error;
  }
};

// 자체 서버 트래커 인스턴스
export const [SelfHostedTrack, useSelfHostedTracker] = createTracker<
  SelfHostedContext,
  SelfHostedEventParams
>({
  init: (initialContext, setContext) => {
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const environment = process.env.NODE_ENV as 'development' | 'staging' | 'production';

    setContext({
      ...initialContext,
      sessionId,
      environment,
    });
  },

  send: (params, context) => {
    return retryWithBackoff(() => sendEvent(params, context));
  },

  DOMEvents: {
    onClick: (params, context) => {
      retryWithBackoff(() => sendEvent({
        eventName: 'click',
        category: 'engagement',
        action: 'click',
        label: params.eventLabel || 'button_click',
        customData: {
          button_id: params.buttonId,
          button_text: params.buttonText,
          page_location: window.location.pathname,
          ...params.customData,
        },
      }, context));
    },
  },

  impression: {
    onImpression: (params, context) => {
      retryWithBackoff(() => sendEvent({
        eventName: 'impression',
        category: 'engagement',
        action: 'view',
        label: params.elementId,
        customData: {
          element_id: params.elementId,
          element_type: params.elementType,
          visibility_percentage: params.visibilityPercentage,
          ...params.customData,
        },
      }, context));
    },
    options: {
      threshold: 0.5,
      freezeOnceVisible: true,
    },
  },

  pageView: {
    onPageView: (params, context) => {
      retryWithBackoff(() => sendEvent({
        eventName: 'page_view',
        category: 'navigation',
        action: 'page_view',
        label: params.pagePath || window.location.pathname,
        customData: {
          page_title: params.pageTitle || document.title,
          page_path: params.pagePath || window.location.pathname,
          referrer: params.referrer || document.referrer,
          ...params.customData,
        },
      }, context));
    },
  },

  // 배칭 설정
  batch: {
    enable: true,
    interval: 3000, // 3초마다 배치 전송
    thresholdSize: 10, // 최대 10개 이벤트
    onFlush: async (batch, isBrowserClosing) => {
      const batchData = {
        events: batch.map(event => ({
          eventName: event.eventName,
          userId: event.userId,
          sessionId: event.sessionId,
          timestamp: event.timestamp,
          pageInfo: {
            url: window.location.href,
            title: document.title,
            referrer: document.referrer,
          },
          userAgent: navigator.userAgent,
          params: event.params,
          metadata: {
            source: 'client',
            version: '1.0.0',
            environment: process.env.NODE_ENV,
          },
        })),
        batchId: `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        timestamp: Date.now(),
      };

      try {
        if (isBrowserClosing) {
          // 브라우저 종료 시 sendBeacon 사용
          navigator.sendBeacon(
            `${API_CONFIG.baseUrl}/api/events/batch`,
            JSON.stringify(batchData)
          );
          return;
        }

        const response = await fetch(`${API_CONFIG.baseUrl}/api/events/batch`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${API_CONFIG.apiKey}`,
          },
          body: JSON.stringify(batchData),
        });

        if (!response.ok) {
          throw new Error(`Batch upload failed: ${response.status}`);
        }

        const result = await response.json();
        console.log('✅ 배치 이벤트 전송 성공:', result);
      } catch (error) {
        console.error('❌ 배치 이벤트 전송 실패:', error);

        // 실패한 이벤트를 로컬 스토리지에 저장하여 나중에 재전송
        this.saveFailedEvents(batchData);
      }
    },
    onError: (error) => {
      console.error('배치 처리 오류:', error);
    },
  },
});

// 실패한 이벤트 저장 및 재전송
const saveFailedEvents = (batchData: any) => {
  try {
    const failedEvents = JSON.parse(localStorage.getItem('failedEvents') || '[]');
    failedEvents.push(batchData);
    localStorage.setItem('failedEvents', JSON.stringify(failedEvents.slice(-50))); // 최대 50개 저장
  } catch (error) {
    console.error('실패한 이벤트 저장 실패:', error);
  }
};

// 재전송 함수
export const retryFailedEvents = async () => {
  try {
    const failedEvents = JSON.parse(localStorage.getItem('failedEvents') || '[]');
    if (failedEvents.length === 0) return;

    for (const batchData of failedEvents) {
      try {
        const response = await fetch(`${API_CONFIG.baseUrl}/api/events/batch`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${API_CONFIG.apiKey}`,
          },
          body: JSON.stringify(batchData),
        });

        if (response.ok) {
          console.log('✅ 실패한 이벤트 재전송 성공');
        }
      } catch (error) {
        console.error('❌ 실패한 이벤트 재전송 실패:', error);
      }
    }

    // 성공한 이벤트 제거
    localStorage.removeItem('failedEvents');
  } catch (error) {
    console.error('재전송 처리 실패:', error);
  }
};

export { SelfHostedTrack, useSelfHostedTracker };
```

## 실제 사용 예제

### 1. 기본 사용법

```tsx
// components/SelfHostedExample.tsx
import { SelfHostedTrack, useSelfHostedTracker, retryFailedEvents } from "../trackers/selfHostedTracker";

function SelfHostedExample() {
  const { track } = useSelfHostedTracker();

  const handlePurchase = async () => {
    try {
      // 구매 로직
      const purchaseResult = await processPurchase();

      // 자체 서버로 이벤트 전송
      await track({
        eventName: "purchase",
        category: "ecommerce",
        action: "purchase",
        value: purchaseResult.amount,
        customData: {
          transaction_id: purchaseResult.transactionId,
          currency: "KRW",
          items: purchaseResult.items,
          payment_method: purchaseResult.paymentMethod,
        },
      });

      console.log("구매 이벤트가 서버에 전송되었습니다.");
    } catch (error) {
      console.error("구매 이벤트 전송 실패:", error);
    }
  };

  const handleError = async () => {
    try {
      await track({
        eventName: "error",
        category: "system",
        action: "error_occurred",
        customData: {
          error_type: "validation_error",
          error_message: "사용자 입력 검증 실패",
          error_code: "VAL_001",
          stack_trace: new Error().stack,
        },
      });
    } catch (error) {
      console.error("에러 이벤트 전송 실패:", error);
    }
  };

  return (
    <SelfHostedTrack.Provider
      initialContext={{
        userId: "user-123",
        apiKey: process.env.NEXT_PUBLIC_EVENT_API_KEY,
      }}
    >
      {/* 페이지 뷰 트래킹 */}
      <SelfHostedTrack.PageView
        params={{
          pagePath: "/self-hosted-example",
          pageTitle: "자체 서버 트래킹 예제",
          customData: {
            page_category: "demo",
            user_segment: "premium",
          },
        }}
      />

      <div>
        <h1>자체 서버 트래킹 예제</h1>

        {/* 상품 노출 트래킹 */}
        <SelfHostedTrack.Impression
          params={{
            elementId: "product-banner",
            elementType: "banner",
            visibilityPercentage: 80,
            customData: {
              banner_type: "promotional",
              campaign_id: "summer_sale_2024",
            },
          }}
        >
          <div className="product-banner">
            <h2>여름 세일!</h2>
            <p>모든 상품 20% 할인</p>
          </div>
        </SelfHostedTrack.Impression>

        {/* 버튼 클릭 트래킹 */}
        <SelfHostedTrack.Click
          params={{
            buttonId: "purchase-button",
            buttonText: "구매하기",
            customData: {
              product_id: "prod-123",
              product_name: "샘플 상품",
              price: 29900,
            },
          }}
        >
          <button onClick={handlePurchase}>구매하기</button>
        </SelfHostedTrack.Click>

        <button onClick={handleError}>에러 발생 시뮬레이션</button>

        <button onClick={retryFailedEvents}>실패한 이벤트 재전송</button>
      </div>
    </SelfHostedTrack.Provider>
  );
}
```

### 2. 고급 사용법 - 커스텀 이벤트

```tsx
// components/AdvancedSelfHostedExample.tsx
import { SelfHostedTrack, useSelfHostedTracker } from "../trackers/selfHostedTracker";

function AdvancedSelfHostedExample() {
  const { track } = useSelfHostedTracker();

  const handleUserAction = async (action: string, data: any) => {
    try {
      await track({
        eventName: "user_action",
        category: "user_engagement",
        action: action,
        customData: {
          action_type: action,
          action_data: data,
          timestamp: Date.now(),
          user_agent: navigator.userAgent,
          screen_resolution: `${screen.width}x${screen.height}`,
          time_on_page: performance.now(),
        },
      });
    } catch (error) {
      console.error("사용자 액션 이벤트 전송 실패:", error);
    }
  };

  const handleFormSubmission = async (formData: any) => {
    try {
      await track({
        eventName: "form_submit",
        category: "conversion",
        action: "form_submitted",
        customData: {
          form_id: formData.formId,
          form_type: formData.formType,
          field_count: Object.keys(formData.fields).length,
          validation_errors: formData.validationErrors || 0,
          submission_time: Date.now(),
          form_data: formData.fields,
        },
      });
    } catch (error) {
      console.error("폼 제출 이벤트 전송 실패:", error);
    }
  };

  return (
    <SelfHostedTrack.Provider
      initialContext={{
        userId: "user-123",
        apiKey: process.env.NEXT_PUBLIC_EVENT_API_KEY,
      }}
    >
      <div>
        <h1>고급 자체 서버 트래킹</h1>

        <button onClick={() => handleUserAction("scroll", { depth: 50 })}>스크롤 이벤트</button>

        <button onClick={() => handleUserAction("search", { query: "test" })}>검색 이벤트</button>

        <button
          onClick={() =>
            handleFormSubmission({
              formId: "contact-form",
              formType: "contact",
              fields: { name: "John", email: "john@example.com" },
              validationErrors: 0,
            })
          }
        >
          폼 제출 이벤트
        </button>
      </div>
    </SelfHostedTrack.Provider>
  );
}
```
