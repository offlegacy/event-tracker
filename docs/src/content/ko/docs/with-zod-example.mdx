# Zodì™€ í•¨ê»˜ ì‚¬ìš©í•˜ê¸°

[Zod](https://zod.dev/)ì™€ í•¨ê»˜ `event-tracker`ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°•ë ¥í•œ ë°ì´í„° íƒ€ì… ê²€ì¦ì„ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤. Zodë¥¼ í†µí•œ ìŠ¤í‚¤ë§ˆ ê¸°ë°˜ ê²€ì¦ìœ¼ë¡œ ëŸ°íƒ€ì„ ì´ì „ì— ì˜¤ë¥˜ë¥¼ ë°©ì§€í•˜ê³  ë°ì´í„° ì‹ ë¢°ì„±ì„ ë³´ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ê¸°ë³¸ ì„¤ì •

### 1. ìŠ¤í‚¤ë§ˆ ì •ì˜

```tsx
// schemas/eventSchemas.ts
import { z } from "zod";

// ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸ ìŠ¤í‚¤ë§ˆ
export const userContextSchema = z.object({
  userId: z.string().min(1, "ì‚¬ìš©ì IDëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤"),
  userType: z.enum(["free", "premium", "enterprise"]).optional(),
  sessionId: z.string().optional(),
  trackingConsent: z.boolean().default(true),
});

// í˜ì´ì§€ ë·° ì´ë²¤íŠ¸ ìŠ¤í‚¤ë§ˆ
export const pageViewSchema = z.object({
  pagePath: z.string().min(1, "í˜ì´ì§€ ê²½ë¡œëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤"),
  pageTitle: z.string().optional(),
  referrer: z.string().optional(),
  category: z.enum(["home", "product", "blog", "admin"]).optional(),
  customData: z.record(z.unknown()).optional(),
});

// í´ë¦­ ì´ë²¤íŠ¸ ìŠ¤í‚¤ë§ˆ
export const clickSchema = z.object({
  buttonId: z.string().min(1, "ë²„íŠ¼ IDëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤"),
  buttonText: z.string().optional(),
  buttonType: z.enum(["primary", "secondary", "danger", "link"]).optional(),
  elementPosition: z
    .object({
      x: z.number(),
      y: z.number(),
    })
    .optional(),
  customData: z.record(z.unknown()).optional(),
});

// ë…¸ì¶œ ì´ë²¤íŠ¸ ìŠ¤í‚¤ë§ˆ
export const impressionSchema = z.object({
  elementId: z.string().min(1, "ìš”ì†Œ IDëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤"),
  elementType: z.enum(["banner", "product", "article", "video"]),
  visibilityPercentage: z.number().min(0).max(100),
  timeInView: z.number().positive().optional(),
  customData: z.record(z.unknown()).optional(),
});

// ì „ììƒê±°ë˜ ì´ë²¤íŠ¸ ìŠ¤í‚¤ë§ˆ
export const ecommerceSchema = z.object({
  productId: z.string().min(1, "ìƒí’ˆ IDëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤"),
  productName: z.string().min(1, "ìƒí’ˆëª…ì€ í•„ìˆ˜ì…ë‹ˆë‹¤"),
  price: z.number().positive("ê°€ê²©ì€ ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤"),
  currency: z.string().length(3, "í†µí™”ëŠ” 3ìë¦¬ì—¬ì•¼ í•©ë‹ˆë‹¤"),
  quantity: z.number().int().positive("ìˆ˜ëŸ‰ì€ ì–‘ì˜ ì •ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤"),
  category: z.string().optional(),
  brand: z.string().optional(),
});

// êµ¬ë§¤ ì´ë²¤íŠ¸ ìŠ¤í‚¤ë§ˆ
export const purchaseSchema = z.object({
  transactionId: z.string().min(1, "ê±°ë˜ IDëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤"),
  value: z.number().positive("ê±°ë˜ ê¸ˆì•¡ì€ ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤"),
  currency: z.string().length(3, "í†µí™”ëŠ” 3ìë¦¬ì—¬ì•¼ í•©ë‹ˆë‹¤"),
  items: z.array(ecommerceSchema).min(1, "ìµœì†Œ 1ê°œì˜ ìƒí’ˆì´ í•„ìš”í•©ë‹ˆë‹¤"),
  shipping: z.number().nonnegative().optional(),
  tax: z.number().nonnegative().optional(),
});

// ê²€ìƒ‰ ì´ë²¤íŠ¸ ìŠ¤í‚¤ë§ˆ
export const searchSchema = z.object({
  query: z.string().min(1, "ê²€ìƒ‰ì–´ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤"),
  category: z.string().optional(),
  filters: z.record(z.unknown()).optional(),
  resultCount: z.number().int().nonnegative().optional(),
});

// í¼ ì œì¶œ ì´ë²¤íŠ¸ ìŠ¤í‚¤ë§ˆ
export const formSubmitSchema = z.object({
  formId: z.string().min(1, "í¼ IDëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤"),
  formType: z.enum(["contact", "signup", "checkout", "feedback"]),
  fieldCount: z.number().int().positive("í•„ë“œ ìˆ˜ëŠ” ì–‘ì˜ ì •ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤"),
  validationErrors: z.number().int().nonnegative().optional(),
  customData: z.record(z.unknown()).optional(),
});

// ìŠ¤í‚¤ë§ˆ ëª¨ìŒ
export const eventSchemas = {
  page_view: pageViewSchema,
  click: clickSchema,
  impression: impressionSchema,
  add_to_cart: ecommerceSchema,
  purchase: purchaseSchema,
  search: searchSchema,
  form_submit: formSubmitSchema,
} as const;

// íƒ€ì… ì¶”ë¡ 
export type UserContext = z.infer<typeof userContextSchema>;
export type PageViewEvent = z.infer<typeof pageViewSchema>;
export type ClickEvent = z.infer<typeof clickSchema>;
export type ImpressionEvent = z.infer<typeof impressionSchema>;
export type EcommerceEvent = z.infer<typeof ecommerceSchema>;
export type PurchaseEvent = z.infer<typeof purchaseSchema>;
export type SearchEvent = z.infer<typeof searchSchema>;
export type FormSubmitEvent = z.infer<typeof formSubmitSchema>;
```

### 2. íŠ¸ë˜ì»¤ ì„¤ì •

```tsx
// tracker/validatedTracker.ts
import { createTracker } from "@offlegacy/event-tracker";
import { eventSchemas, UserContext } from "../schemas/eventSchemas";

// ì´ë²¤íŠ¸ ì „ì†¡ í•¨ìˆ˜
const sendEvent = async (eventName: string, params: any, context: UserContext) => {
  try {
    // ì‹¤ì œ ì• ë„ë¦¬í‹±ìŠ¤ ì„œë¹„ìŠ¤ë¡œ ì „ì†¡
    await analytics.track(eventName, {
      ...params,
      userId: context.userId,
      sessionId: context.sessionId,
      timestamp: Date.now(),
    });

    console.log(`âœ… ì´ë²¤íŠ¸ ì „ì†¡ ì„±ê³µ: ${eventName}`, params);
  } catch (error) {
    console.error(`âŒ ì´ë²¤íŠ¸ ì „ì†¡ ì‹¤íŒ¨: ${eventName}`, error);
  }
};

// ê²€ì¦ëœ íŠ¸ë˜ì»¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
export const [Track, useTracker] = createTracker<UserContext, any, typeof eventSchemas>({
  // ì´ˆê¸°í™” í•¨ìˆ˜
  init: (initialContext, setContext) => {
    // ì„¸ì…˜ ID ìƒì„±
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // ì»¨í…ìŠ¤íŠ¸ ê²€ì¦ ë° ì„¤ì •
    const validatedContext = userContextSchema.parse({
      ...initialContext,
      sessionId,
    });

    setContext(validatedContext);
  },

  // ì´ë²¤íŠ¸ ì „ì†¡ í•¨ìˆ˜
  send: (params, context) => {
    sendEvent("custom_event", params, context);
  },

  // DOM ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
  DOMEvents: {
    onClick: (params, context) => {
      sendEvent("click", params, context);
    },
  },

  // ë…¸ì¶œ ì´ë²¤íŠ¸ ì„¤ì •
  impression: {
    onImpression: (params, context) => {
      sendEvent("impression", params, context);
    },
    options: {
      threshold: 0.5,
      freezeOnceVisible: true,
    },
  },

  // í˜ì´ì§€ ë·° ì„¤ì •
  pageView: {
    onPageView: (params, context) => {
      sendEvent("page_view", params, context);
    },
  },

  // ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì„¤ì •
  schemas: {
    schemas: eventSchemas,
    onSchemaError: (error) => {
      console.error("ğŸš¨ ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì˜¤ë¥˜:", {
        message: error.message,
        issues: error.issues,
        path: error.issues.map((issue) => issue.path.join(".")),
      });

      // ê°œë°œ í™˜ê²½ì—ì„œëŠ” ë” ìì„¸í•œ ì •ë³´ ì¶œë ¥
      if (process.env.NODE_ENV === "development") {
        console.group("ğŸ” ìƒì„¸ ì˜¤ë¥˜ ì •ë³´");
        error.issues.forEach((issue, index) => {
          console.log(`${index + 1}. ê²½ë¡œ: ${issue.path.join(".")}`);
          console.log(`   ë©”ì‹œì§€: ${issue.message}`);
          console.log(`   ì½”ë“œ: ${issue.code}`);
          console.log(`   ë°›ì€ ê°’:`, issue.received);
        });
        console.groupEnd();
      }
    },
    abortOnError: true, // ê²€ì¦ ì‹¤íŒ¨ ì‹œ ì´ë²¤íŠ¸ ì¤‘ë‹¨
  },
});

export { Track, useTracker };
```

## ì‹¤ì œ ì‚¬ìš© ì˜ˆì œ

### 1. ì „ììƒê±°ë˜ ì‚¬ì´íŠ¸

```tsx
// components/ProductPage.tsx
import { Track, useTracker } from "../tracker/validatedTracker";
import { userContextSchema } from "../schemas/eventSchemas";

interface Product {
  id: string;
  name: string;
  price: number;
  category: string;
  brand: string;
}

function ProductPage({ product }: { product: Product }) {
  const { track } = useTracker();

  const handleAddToCart = async () => {
    try {
      // ì¥ë°”êµ¬ë‹ˆ ì¶”ê°€ ë¡œì§
      await addToCart(product.id);

      // ê²€ì¦ëœ ì´ë²¤íŠ¸ ì „ì†¡
      await track({
        eventName: "add_to_cart",
        productId: product.id,
        productName: product.name,
        price: product.price,
        currency: "KRW",
        quantity: 1,
        category: product.category,
        brand: product.brand,
      });
    } catch (error) {
      console.error("ì¥ë°”êµ¬ë‹ˆ ì¶”ê°€ ì‹¤íŒ¨:", error);
    }
  };

  const handlePurchase = async () => {
    try {
      // êµ¬ë§¤ ë¡œì§
      const purchaseResult = await processPurchase(product.id);

      if (purchaseResult.success) {
        // ê²€ì¦ëœ êµ¬ë§¤ ì´ë²¤íŠ¸ ì „ì†¡
        await track({
          eventName: "purchase",
          transactionId: purchaseResult.transactionId,
          value: product.price,
          currency: "KRW",
          items: [
            {
              productId: product.id,
              productName: product.name,
              price: product.price,
              currency: "KRW",
              quantity: 1,
              category: product.category,
              brand: product.brand,
            },
          ],
          shipping: 0,
          tax: 0,
        });
      }
    } catch (error) {
      console.error("êµ¬ë§¤ ì²˜ë¦¬ ì‹¤íŒ¨:", error);
    }
  };

  return (
    <Track.Provider
      initialContext={{
        userId: "user-123",
        userType: "premium",
        trackingConsent: true,
      }}
    >
      {/* í˜ì´ì§€ ë·° íŠ¸ë˜í‚¹ */}
      <Track.PageView
        schema="page_view"
        params={{
          pagePath: `/products/${product.id}`,
          pageTitle: `${product.name} - ìƒí’ˆ ìƒì„¸`,
          category: "product",
          customData: {
            product_id: product.id,
            product_category: product.category,
          },
        }}
      />

      <div className="product-detail">
        <h1>{product.name}</h1>
        <p>â‚©{product.price.toLocaleString()}</p>

        {/* ìƒí’ˆ ì´ë¯¸ì§€ ë…¸ì¶œ íŠ¸ë˜í‚¹ */}
        <Track.Impression
          schema="impression"
          params={{
            elementId: `product-image-${product.id}`,
            elementType: "product",
            visibilityPercentage: 80,
            customData: {
              product_id: product.id,
              image_position: "main",
            },
          }}
        >
          <img src={product.imageUrl} alt={product.name} className="product-image" />
        </Track.Impression>

        {/* ì¥ë°”êµ¬ë‹ˆ ë²„íŠ¼ í´ë¦­ íŠ¸ë˜í‚¹ */}
        <Track.Click
          schema="click"
          params={{
            buttonId: "add-to-cart",
            buttonText: "ì¥ë°”êµ¬ë‹ˆ ë‹´ê¸°",
            buttonType: "primary",
            customData: {
              product_id: product.id,
              product_name: product.name,
              product_price: product.price,
            },
          }}
        >
          <button onClick={handleAddToCart}>ì¥ë°”êµ¬ë‹ˆ ë‹´ê¸°</button>
        </Track.Click>

        {/* êµ¬ë§¤ ë²„íŠ¼ - useTracker ì‚¬ìš© */}
        <button onClick={handlePurchase}>ë°”ë¡œ êµ¬ë§¤</button>
      </div>
    </Track.Provider>
  );
}
```

### 2. ê²€ìƒ‰ ê¸°ëŠ¥

```tsx
// components/SearchComponent.tsx
import { Track, useTracker } from "../tracker/validatedTracker";

function SearchComponent() {
  const { track } = useTracker();
  const [query, setQuery] = useState("");
  const [results, setResults] = useState([]);

  const handleSearch = async (searchQuery: string) => {
    try {
      const searchResults = await performSearch(searchQuery);
      setResults(searchResults);

      // ê²€ì¦ëœ ê²€ìƒ‰ ì´ë²¤íŠ¸ ì „ì†¡
      await track({
        eventName: "search",
        query: searchQuery,
        category: "products",
        resultCount: searchResults.length,
        filters: {
          category: "all",
          price_range: "all",
        },
      });
    } catch (error) {
      console.error("ê²€ìƒ‰ ì‹¤íŒ¨:", error);
    }
  };

  return (
    <Track.Provider
      initialContext={{
        userId: "user-123",
        userType: "free",
        trackingConsent: true,
      }}
    >
      <div className="search-container">
        <Track.Click
          schema="click"
          params={{
            buttonId: "search-button",
            buttonText: "ê²€ìƒ‰",
            buttonType: "primary",
            customData: {
              search_context: "header",
            },
          }}
        >
          <button onClick={() => handleSearch(query)}>ê²€ìƒ‰</button>
        </Track.Click>

        <input
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
        />
      </div>
    </Track.Provider>
  );
}
```

### 3. í¼ ì œì¶œ

```tsx
// components/ContactForm.tsx
import { Track, useTracker } from "../tracker/validatedTracker";

function ContactForm() {
  const { track } = useTracker();
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    message: "",
  });
  const [errors, setErrors] = useState({});

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    try {
      // í¼ ê²€ì¦
      const validationErrors = validateForm(formData);
      setErrors(validationErrors);

      if (Object.keys(validationErrors).length === 0) {
        // í¼ ì œì¶œ ë¡œì§
        await submitForm(formData);

        // ê²€ì¦ëœ í¼ ì œì¶œ ì´ë²¤íŠ¸ ì „ì†¡
        await track({
          eventName: "form_submit",
          formId: "contact-form",
          formType: "contact",
          fieldCount: Object.keys(formData).length,
          validationErrors: 0,
          customData: {
            form_name: "contact_form",
            submission_method: "web",
          },
        });
      } else {
        // ê²€ì¦ ì˜¤ë¥˜ê°€ ìˆëŠ” ê²½ìš°
        await track({
          eventName: "form_submit",
          formId: "contact-form",
          formType: "contact",
          fieldCount: Object.keys(formData).length,
          validationErrors: Object.keys(validationErrors).length,
          customData: {
            form_name: "contact_form",
            error_fields: Object.keys(validationErrors),
          },
        });
      }
    } catch (error) {
      console.error("í¼ ì œì¶œ ì‹¤íŒ¨:", error);
    }
  };

  return (
    <Track.Provider
      initialContext={{
        userId: "user-123",
        userType: "free",
        trackingConsent: true,
      }}
    >
      <form onSubmit={handleSubmit}>
        <input
          type="text"
          name="name"
          value={formData.name}
          onChange={(e) => setFormData({ ...formData, name: e.target.value })}
          placeholder="ì´ë¦„"
        />
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={(e) => setFormData({ ...formData, email: e.target.value })}
          placeholder="ì´ë©”ì¼"
        />
        <textarea
          name="message"
          value={formData.message}
          onChange={(e) => setFormData({ ...formData, message: e.target.value })}
          placeholder="ë©”ì‹œì§€"
        />

        <Track.Click
          schema="click"
          params={{
            buttonId: "submit-contact",
            buttonText: "ì œì¶œ",
            buttonType: "primary",
            customData: {
              form_id: "contact-form",
            },
          }}
        >
          <button type="submit">ì œì¶œ</button>
        </Track.Click>
      </form>
    </Track.Provider>
  );
}
```

## ê³ ê¸‰ ê¸°ëŠ¥

### 1. ë™ì  ìŠ¤í‚¤ë§ˆ ê²€ì¦

```tsx
// schemas/dynamicSchemas.ts
import { z } from "zod";

// ì¡°ê±´ë¶€ ìŠ¤í‚¤ë§ˆ ìƒì„± í•¨ìˆ˜
export const createConditionalSchema = (userType: string) => {
  const baseSchema = z.object({
    eventName: z.string(),
    timestamp: z.number(),
  });

  if (userType === "premium") {
    return baseSchema.extend({
      premiumFeature: z.string(),
      usageCount: z.number().positive(),
    });
  }

  return baseSchema;
};

// ë™ì  ì´ë²¤íŠ¸ ìŠ¤í‚¤ë§ˆ
export const dynamicEventSchemas = {
  conditional_event: z.object({
    eventName: z.string(),
    userType: z.enum(["free", "premium"]),
    // ì¡°ê±´ë¶€ í•„ë“œ
    premiumData: z
      .object({
        feature: z.string(),
        usage: z.number(),
      })
      .optional(),
  }),

  // ë°°ì—´ ê¸°ë°˜ ìŠ¤í‚¤ë§ˆ
  batch_events: z.array(
    z.object({
      eventName: z.string(),
      params: z.record(z.unknown()),
      timestamp: z.number(),
    }),
  ),

  // ìœ ë‹ˆì˜¨ íƒ€ì… ìŠ¤í‚¤ë§ˆ
  mixed_event: z.union([
    z.object({
      type: z.literal("click"),
      buttonId: z.string(),
      position: z.object({ x: z.number(), y: z.number() }),
    }),
    z.object({
      type: z.literal("scroll"),
      scrollDepth: z.number(),
      direction: z.enum(["up", "down"]),
    }),
  ]),
};
```

### 2. ì»¤ìŠ¤í…€ ê²€ì¦ ë¡œì§

```tsx
// utils/customValidation.ts
import { z } from "zod";

// ì»¤ìŠ¤í…€ ê²€ì¦ í•¨ìˆ˜
export const customValidators = {
  // ì´ë©”ì¼ ë„ë©”ì¸ ê²€ì¦
  emailDomain: (allowedDomains: string[]) =>
    z
      .string()
      .email()
      .refine((email) => allowedDomains.some((domain) => email.endsWith(domain)), {
        message: `í—ˆìš©ë˜ì§€ ì•ŠëŠ” ì´ë©”ì¼ ë„ë©”ì¸ì…ë‹ˆë‹¤. í—ˆìš©: ${allowedDomains.join(", ")}`,
      }),

  // ë¹„ë°€ë²ˆí˜¸ ë³µì¡ë„ ê²€ì¦
  strongPassword: z
    .string()
    .min(8, "ë¹„ë°€ë²ˆí˜¸ëŠ” ìµœì†Œ 8ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
    .regex(/[A-Z]/, "ëŒ€ë¬¸ìê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤")
    .regex(/[a-z]/, "ì†Œë¬¸ìê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤")
    .regex(/[0-9]/, "ìˆ«ìê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤")
    .regex(/[^A-Za-z0-9]/, "íŠ¹ìˆ˜ë¬¸ìê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤"),

  // í•œêµ­ì–´ ì „í™”ë²ˆí˜¸ ê²€ì¦
  koreanPhoneNumber: z.string().regex(/^01[0-9]-\d{3,4}-\d{4}$/, "ì˜¬ë°”ë¥¸ í•œêµ­ ì „í™”ë²ˆí˜¸ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤"),

  // ê°€ê²© ë²”ìœ„ ê²€ì¦
  priceRange: (min: number, max: number) =>
    z
      .number()
      .positive()
      .refine((price) => price >= min && price <= max, { message: `ê°€ê²©ì€ ${min}ì›ì—ì„œ ${max}ì› ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤` }),
};

// ì¡°ê±´ë¶€ ìŠ¤í‚¤ë§ˆ
export const conditionalSchemas = {
  // ì‚¬ìš©ì íƒ€ì…ì— ë”°ë¥¸ ë‹¤ë¥¸ ê²€ì¦ ê·œì¹™
  userAction: (userType: string) => {
    const baseSchema = z.object({
      action: z.string(),
      timestamp: z.number(),
    });

    if (userType === "premium") {
      return baseSchema.extend({
        premiumFeature: z.string(),
        usageLimit: z.number().optional(),
      });
    }

    return baseSchema.extend({
      feature: z.string(),
      upgradePrompt: z.boolean().optional(),
    });
  },
};
```

### 3. ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬

```tsx
// tracker/errorHandlingTracker.ts
import { createTracker } from "@offlegacy/event-tracker";
import { eventSchemas } from "../schemas/eventSchemas";

export const [Track, useTracker] = createTracker({
  // ... ê¸°ì¡´ ì„¤ì • ...

  schemas: {
    schemas: eventSchemas,
    onSchemaError: (error) => {
      // 1. ë¡œê·¸ ê¸°ë¡
      console.error("ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì˜¤ë¥˜:", error);

      // 2. ì—ëŸ¬ ì¶”ì  ì„œë¹„ìŠ¤ë¡œ ì „ì†¡
      errorTracking.captureException(error);

      // 3. ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ (ê°œë°œ í™˜ê²½)
      if (process.env.NODE_ENV === "development") {
        toast.error(`ìŠ¤í‚¤ë§ˆ ê²€ì¦ ì‹¤íŒ¨: ${error.message}`);
      }

      // 4. ëŒ€ì²´ ë°ì´í„°ë¡œ ì´ë²¤íŠ¸ ì „ì†¡
      const fallbackData = createFallbackData(error);
      if (fallbackData) {
        analytics.track("schema_validation_fallback", {
          originalEvent: error.issues[0]?.path[0],
          errorMessage: error.message,
          fallbackData,
        });
      }
    },
    abortOnError: false, // ì˜¤ë¥˜ ì‹œì—ë„ ì´ë²¤íŠ¸ ì „ì†¡ ê³„ì†
  },
});

// ëŒ€ì²´ ë°ì´í„° ìƒì„± í•¨ìˆ˜
function createFallbackData(error: z.ZodError) {
  const firstIssue = error.issues[0];
  if (!firstIssue) return null;

  const eventName = firstIssue.path[0];
  const receivedData = firstIssue.received;

  // ê¸°ë³¸ êµ¬ì¡°ë¡œ ëŒ€ì²´ ë°ì´í„° ìƒì„±
  return {
    eventName,
    timestamp: Date.now(),
    originalData: receivedData,
    validationErrors: error.issues.map((issue) => ({
      path: issue.path.join("."),
      message: issue.message,
    })),
  };
}
```

## ì„±ëŠ¥ ìµœì í™”

### 1. ìŠ¤í‚¤ë§ˆ ìºì‹±

```tsx
// utils/schemaCache.ts
import { z } from "zod";

class SchemaCache {
  private cache = new Map<string, z.ZodSchema>();

  getSchema(schemaName: string, schemaFactory: () => z.ZodSchema): z.ZodSchema {
    if (!this.cache.has(schemaName)) {
      this.cache.set(schemaName, schemaFactory());
    }
    return this.cache.get(schemaName)!;
  }

  clear() {
    this.cache.clear();
  }
}

export const schemaCache = new SchemaCache();

// ì‚¬ìš© ì˜ˆì‹œ
const cachedSchema = schemaCache.getSchema("dynamic_event", () =>
  z.object({
    eventName: z.string(),
    dynamicField: z.string(),
  }),
);
```

### 2. ë°°ì¹˜ ê²€ì¦

```tsx
// utils/batchValidation.ts
import { z } from 'zod';

export const batchValidate = <T>(
  schema: z.ZodSchema<T>,
  dataArray: unknown[]
): { valid: T[], invalid: { data: unknown; error: z.ZodError }[] } => {
  const valid: T[] = [];
  const invalid: { data: unknown; error: z.ZodError }[] = [];

  dataArray.forEach(data => {
    try {
      const validated = schema.parse(data);
      valid.push(validated);
    } catch (error) {
      if (error instanceof z.ZodError) {
        invalid.push({ data, error });
      }
    }
  });

  return { valid, invalid };
};
```
